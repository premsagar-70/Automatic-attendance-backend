const mongoose = require('mongoose');

const qrCodeLogSchema = new mongoose.Schema({
  // QR Code information
  code: {
    type: String,
    required: [true, 'QR code is required'],
    unique: true,
    index: true
  },
  
  // Session reference
  session: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Session',
    required: [true, 'Session reference is required']
  },
  
  // QR Code generation details
  generatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Generated by user is required']
  },
  generatedAt: {
    type: Date,
    default: Date.now
  },
  
  // QR Code settings
  settings: {
    expiresAt: {
      type: Date,
      required: [true, 'Expiration time is required']
    },
    maxUses: {
      type: Number,
      default: null // null means unlimited uses
    },
    isActive: {
      type: Boolean,
      default: true
    },
    allowMultipleScans: {
      type: Boolean,
      default: false
    }
  },
  
  // Usage tracking
  usage: {
    totalScans: {
      type: Number,
      default: 0
    },
    uniqueScans: {
      type: Number,
      default: 0
    },
    lastScannedAt: {
      type: Date
    }
  },
  
  // Scan records
  scans: [{
    scannedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    scannedAt: {
      type: Date,
      default: Date.now
    },
    deviceInfo: {
      userAgent: String,
      platform: String,
      browser: String,
      ipAddress: String
    },
    location: {
      latitude: Number,
      longitude: Number,
      accuracy: Number,
      address: String
    },
    isValid: {
      type: Boolean,
      default: true
    },
    reason: String // Reason for invalid scan
  }],
  
  // Security and validation
  security: {
    ipWhitelist: [String],
    locationRestriction: {
      enabled: {
        type: Boolean,
        default: false
      },
      center: {
        latitude: Number,
        longitude: Number
      },
      radius: Number // in meters
    },
    timeRestriction: {
      enabled: {
        type: Boolean,
        default: false
      },
      allowedStartTime: String, // HH:MM format
      allowedEndTime: String    // HH:MM format
    }
  },
  
  // QR Code data payload
  payload: {
    sessionId: String,
    timestamp: Date,
    checksum: String,
    version: {
      type: String,
      default: '1.0'
    }
  },
  
  // Status and lifecycle
  status: {
    type: String,
    enum: ['active', 'expired', 'deactivated', 'exhausted'],
    default: 'active'
  },
  
  // System fields
  isActive: {
    type: Boolean,
    default: true
  },
  
  // Timestamps
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Virtual for remaining uses
qrCodeLogSchema.virtual('remainingUses').get(function() {
  if (this.settings.maxUses === null) return null;
  return Math.max(0, this.settings.maxUses - this.usage.totalScans);
});

// Virtual for is expired
qrCodeLogSchema.virtual('isExpired').get(function() {
  return new Date() > this.settings.expiresAt;
});

// Virtual for is exhausted
qrCodeLogSchema.virtual('isExhausted').get(function() {
  return this.settings.maxUses !== null && this.usage.totalScans >= this.settings.maxUses;
});

// Virtual for is valid
qrCodeLogSchema.virtual('isValid').get(function() {
  return this.status === 'active' && 
         this.settings.isActive && 
         !this.isExpired && 
         !this.isExhausted;
});

// Indexes
qrCodeLogSchema.index({ code: 1 });
qrCodeLogSchema.index({ session: 1 });
qrCodeLogSchema.index({ generatedBy: 1 });
qrCodeLogSchema.index({ 'settings.expiresAt': 1 });
qrCodeLogSchema.index({ status: 1 });
qrCodeLogSchema.index({ isActive: 1 });

// Pre-save middleware to update updatedAt
qrCodeLogSchema.pre('save', function(next) {
  this.updatedAt = Date.now();
  
  // Update status based on conditions
  if (this.isExpired) {
    this.status = 'expired';
  } else if (this.isExhausted) {
    this.status = 'exhausted';
  }
  
  next();
});

// Static method to generate QR code
qrCodeLogSchema.statics.generateQRCode = async function(sessionId, generatedBy, settings = {}) {
  const QRCode = require('qrcode');
  
  // Generate unique code
  const code = `QR_${sessionId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  
  // Create payload
  const payload = {
    sessionId: sessionId,
    timestamp: new Date(),
    checksum: require('crypto').createHash('md5').update(code).digest('hex'),
    version: '1.0'
  };
  
  // Generate QR code image
  const qrCodeDataURL = await QRCode.toDataURL(JSON.stringify(payload), {
    width: 200,
    margin: 2,
    color: {
      dark: '#000000',
      light: '#FFFFFF'
    }
  });
  
  // Create QR code log entry
  const qrCodeLog = new this({
    code,
    session: sessionId,
    generatedBy,
    settings: {
      expiresAt: settings.expiresAt || new Date(Date.now() + 30 * 60 * 1000), // 30 minutes default
      maxUses: settings.maxUses || null,
      isActive: true,
      allowMultipleScans: settings.allowMultipleScans || false
    },
    payload,
    security: settings.security || {}
  });
  
  await qrCodeLog.save();
  
  return {
    code,
    dataURL: qrCodeDataURL,
    expiresAt: qrCodeLog.settings.expiresAt,
    qrCodeLog
  };
};

// Instance method to record scan
qrCodeLogSchema.methods.recordScan = function(scannedBy, deviceInfo = {}, location = {}) {
  // Check if scan is valid
  if (!this.isValid) {
    return {
      success: false,
      reason: 'QR code is not valid or has expired'
    };
  }
  
  // Check if multiple scans are allowed
  if (!this.settings.allowMultipleScans) {
    const existingScan = this.scans.find(
      scan => scan.scannedBy.toString() === scannedBy.toString()
    );
    
    if (existingScan) {
      return {
        success: false,
        reason: 'QR code has already been scanned by this user'
      };
    }
  }
  
  // Record the scan
  this.scans.push({
    scannedBy,
    scannedAt: new Date(),
    deviceInfo,
    location
  });
  
  // Update usage statistics
  this.usage.totalScans += 1;
  this.usage.lastScannedAt = new Date();
  
  // Update unique scans count
  const uniqueUsers = new Set(this.scans.map(scan => scan.scannedBy.toString()));
  this.usage.uniqueScans = uniqueUsers.size;
  
  return this.save().then(() => ({
    success: true,
    scanId: this.scans[this.scans.length - 1]._id
  }));
};

// Instance method to deactivate QR code
qrCodeLogSchema.methods.deactivate = function() {
  this.settings.isActive = false;
  this.status = 'deactivated';
  return this.save();
};

// Instance method to validate scan location
qrCodeLogSchema.methods.validateLocation = function(latitude, longitude) {
  if (!this.security.locationRestriction.enabled) {
    return { valid: true };
  }
  
  const { center, radius } = this.security.locationRestriction;
  
  // Calculate distance using Haversine formula
  const R = 6371000; // Earth's radius in meters
  const dLat = (latitude - center.latitude) * Math.PI / 180;
  const dLon = (longitude - center.longitude) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(center.latitude * Math.PI / 180) * Math.cos(latitude * Math.PI / 180) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  const distance = R * c;
  
  return {
    valid: distance <= radius,
    distance: Math.round(distance),
    maxDistance: radius
  };
};

module.exports = mongoose.model('QRCodeLog', qrCodeLogSchema);
